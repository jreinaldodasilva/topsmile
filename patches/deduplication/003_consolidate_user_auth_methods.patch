diff --git a/backend/src/models/mixins/authMixin.ts b/backend/src/models/mixins/authMixin.ts
new file mode 100644
index 0000000..xyz789
--- /dev/null
+++ b/backend/src/models/mixins/authMixin.ts
@@ -0,0 +1,85 @@
+// backend/src/models/mixins/authMixin.ts
+import bcrypt from 'bcrypt';
+import { Schema } from 'mongoose';
+
+export interface AuthMixinConfig {
+  maxAttempts?: {
+    short?: number;
+    medium?: number;
+    long?: number;
+  };
+  lockTimes?: {
+    short?: number; // milliseconds
+    medium?: number;
+    long?: number;
+  };
+  saltRounds?: number;
+}
+
+export const createAuthMixin = (config: AuthMixinConfig = {}) => {
+  const defaultConfig = {
+    maxAttempts: {
+      short: 5,
+      medium: 10,
+      long: 15
+    },
+    lockTimes: {
+      short: 1 * 60 * 60 * 1000, // 1 hour
+      medium: 24 * 60 * 60 * 1000, // 24 hours
+      long: 7 * 24 * 60 * 60 * 1000 // 7 days
+    },
+    saltRounds: 12
+  };
+
+  const finalConfig = { ...defaultConfig, ...config };
+
+  return {
+    schema: {
+      loginAttempts: {
+        type: Number,
+        default: 0
+      },
+      lockUntil: {
+        type: Date
+      }
+    },
+
+    methods: {
+      async comparePassword(candidatePassword: string): Promise<boolean> {
+        return bcrypt.compare(candidatePassword, this.password);
+      },
+
+      async incLoginAttempts(): Promise<void> {
+        if (this.lockUntil && this.lockUntil < new Date()) {
+          this.loginAttempts = 0;
+          this.lockUntil = undefined;
+        }
+
+        this.loginAttempts += 1;
+
+        let lockTime = 0;
+        const { maxAttempts, lockTimes } = finalConfig;
+
+        if (this.loginAttempts >= maxAttempts.long!) {
+          lockTime = lockTimes.long!;
+        } else if (this.loginAttempts >= maxAttempts.medium!) {
+          lockTime = lockTimes.medium!;
+        } else if (this.loginAttempts >= maxAttempts.short!) {
+          lockTime = lockTimes.short!;
+        }
+
+        if (lockTime > 0) {
+          this.lockUntil = new Date(Date.now() + lockTime);
+        }
+
+        await this.save();
+      },
+
+      async resetLoginAttempts(): Promise<void> {
+        this.loginAttempts = 0;
+        this.lockUntil = undefined;
+        await this.save();
+      },
+
+      isLocked(): boolean {
+        return !!(this.lockUntil && this.lockUntil > new Date());
+      }
+    },
+
+    statics: {
+      async hashPassword(password: string): Promise<string> {
+        const salt = await bcrypt.genSalt(finalConfig.saltRounds);
+        return bcrypt.hash(password, salt);
+      }
+    },
+
+    pre: {
+      async save(this: any, next: any) {
+        if (!this.isModified('password')) return next();
+        this.password = await bcrypt.hash(this.password, finalConfig.saltRounds);
+        next();
+      }
+    }
+  };
+};