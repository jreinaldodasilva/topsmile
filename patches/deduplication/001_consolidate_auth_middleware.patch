diff --git a/backend/src/middleware/shared/baseAuth.ts b/backend/src/middleware/shared/baseAuth.ts
new file mode 100644
index 0000000..1234567
--- /dev/null
+++ b/backend/src/middleware/shared/baseAuth.ts
@@ -0,0 +1,85 @@
+// backend/src/middleware/shared/baseAuth.ts
+import { Request, Response, NextFunction } from 'express';
+
+export interface AuthConfig {
+  tokenCookieName?: string;
+  headerPrefix?: string;
+  errorMessages?: {
+    noToken?: string;
+    invalidToken?: string;
+    userInactive?: string;
+  };
+}
+
+export abstract class BaseAuthMiddleware {
+  protected config: AuthConfig;
+
+  constructor(config: AuthConfig = {}) {
+    this.config = {
+      tokenCookieName: 'access_token',
+      headerPrefix: 'Bearer',
+      errorMessages: {
+        noToken: 'Token de acesso obrigat칩rio',
+        invalidToken: 'Token inv치lido ou expirado',
+        userInactive: 'Usu치rio inv치lido ou inativo'
+      },
+      ...config
+    };
+  }
+
+  protected extractToken(req: Request): string | null {
+    const authHeader = req.headers.authorization;
+    if (authHeader) {
+      const match = authHeader.match(new RegExp(`^${this.config.headerPrefix}\\s+(.+)$`, 'i'));
+      if (match && match[1]) return match[1];
+    }
+
+    const cookies = (req as any).cookies;
+    if (cookies && this.config.tokenCookieName) {
+      return cookies[this.config.tokenCookieName] || null;
+    }
+
+    return null;
+  }
+
+  protected sendAuthError(res: Response, message: string, code: string, status = 401): void {
+    res.status(status).json({
+      success: false,
+      message,
+      code
+    });
+  }
+
+  abstract verifyToken(token: string): Promise<any>;
+  abstract attachUserToRequest(req: Request, payload: any): Promise<void>;
+
+  public authenticate() {
+    return async (req: Request, res: Response, next: NextFunction): Promise<void> => {
+      try {
+        const token = this.extractToken(req);
+        
+        if (!token) {
+          this.sendAuthError(res, this.config.errorMessages!.noToken!, 'NO_TOKEN');
+          return;
+        }
+
+        const payload = await this.verifyToken(token);
+        await this.attachUserToRequest(req, payload);
+
+        next();
+      } catch (error) {
+        console.error('Authentication error:', error);
+        
+        let message = this.config.errorMessages!.invalidToken!;
+        let code = 'INVALID_TOKEN';
+        
+        if (error instanceof Error && error.message.includes('expired')) {
+          message = 'Token expirado';
+          code = 'TOKEN_EXPIRED';
+        }
+
+        this.sendAuthError(res, message, code);
+      }
+    };
+  }
+}